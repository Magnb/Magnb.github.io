<!-- 
# Battery Optimization

The Battery Optimization Module serves as the core decision-making engine of the system. It retrieves electricity price forecasts $p_t$ from the forecast bucket via the Integration API and integrates these forecasts with user-defined battery parameters to determine an optimal schedule for operation (i.e., charging and discharging). 
The primary objective is to maximize net revenue while satisfying physical, economic, and market constraints. 
The optimisation problem is formulated as a Mixed-Integer Linear Program (MILP) using the Pyomo framework. 
It explicitly incorporates (i) battery operational constraints, including state-of-charge limits, charge and discharge power ratings, and RTE $\eta$ (see Section~\ref{subsubsec:rte}); 
(ii) economic factors, such as degradation costs, cycle penalties, and DoD penalties (see Section~\ref{subsec:bess_technical}); 
and (iii) market participation rules governing feasible trading schedules (see Section~\ref{sec:integration}).

Constraints representing battery operation, economic costs, and market rules are formulated as mathematical conditions within the optimisation model. 
Physical constraints include SoC dynamics and charging/discharging power limits, while economic aspects are captured through penalty terms for overuse or infeasible operation. 
Logical requirements — such as preventing simultaneous charging and discharging — are implemented using binary variables. 
These non-linear conditions are reformulated with the Big-M method, which expresses them as linear inequalities, ensuring compatibility with MILP solvers \cite{soleimani2008modified}. 
This approach preserves linearity and enables efficient solution by standard optimisation software.

Revenue is defined as the net market income from charging and discharging,  

\begin{equation}
\label{eq:revenue_definition}
\mathrm{Revenue} = 
\sum_{t \in T} \left( p_t \, d_t \, \Delta t - p_t \, c_t \, \Delta t \right).
\end{equation}

Profit is then defined as market revenues net of degradation and penalty costs:

\begin{equation}
\label{eq:profit_definition}
\mathrm{Profit} =
\mathrm{Revenue}
- C_{\deg} \sum_{t \in T} (c_t + d_t) \, \Delta t
- C_{\mathrm{cyc}} \sum_{t \in T} \alpha_t
- K_{\mathrm{DoD}} \sum_{t \in T} \beta_t .
\end{equation}

where the variables and parameters are defined as follows:

    - $T$: Set of discrete time intervals over the optimisation horizon.
    - $p_t$ [€/MWh]: Electricity price at time $t$.
    - $c_t$ [MW]: Charging power at time $t$.
    - $d_t$ [MW]: Discharging power at time $t$.
    - $\Delta t$ [h]: Duration of each interval (e.g., 0.25 h for 15-min data).
    - $C_{\deg}$ [€/MWh]: Degradation cost per unit energy throughput.
    - $\alpha_t \in [0,1]$: Auxiliary variable indicating fractional cycle usage at $t$.
    - $C_{\mathrm{cyc}}$ [€]: Penalty coefficient associated with cycling.
    - $\beta_t \in [0,1]$: Auxiliary variable activating DoD penalties.
    - $K_{\mathrm{DoD}}$ [€]: Penalty coefficient for deep discharges below preferred SOC thresholds.
    - $u^{\mathrm{ch}}_t, u^{\mathrm{dis}}_t \in \{0,1\}$: Binary variables enforcing charging or discharging mode at time $t$.


The optimization problem can then be expressed as:

\begin{equation}
\label{eq:milp_objective}
\underset{\{c_t, d_t, \alpha_t, \beta_t, u^{\mathrm{ch}}_t, u^{\mathrm{dis}}_t\}_{t\in T}}{\text{maximize}}
\quad \mathrm{Profit}.
\end{equation}

## Constraint Implementation and Battery Simulation
\label{subsec:constraint_implementation}
The MILP model enforces battery operational constraints through linearization techniques. The constraints fall into three primary categories: physical battery limitations, economic penalty mechanisms, and operational logic requirements.

### Physical Battery Constraints

Physical constraints guarantee realistic battery behavior by modeling SoC evolution and enforcing power rating limits. The SoC evolves according to the energy balance equation:

\begin{equation}
\label{eq:soc_evolution}
SOC_t = SOC_{t-1} + c_t \cdot \Delta t \cdot \eta - \frac{d_t \cdot \Delta t}{\eta}
\end{equation}

\noindent where the variables and parameters are defined as follows:
\begin{itemize}
    - $SOC_t$ (MWh): State of charge of the battery at time step $t$.
    - $SOC_{t-1}$ (MWh): State of charge at the previous time step $t-1$.
    - $c_t$ (MW): Charging the battery at time step $t$.
    - $d_t$ (MW): Discharging the battery at time step $t$.
    - $\Delta t$ (hours): Duration of each time step (e.g., 0.25 hours for 15-minute intervals).
    - $\eta$ (dimensionless, $0<\eta\leq 1$): Round-trip efficiency (explained in \ref{subsubsec:rte}) coefficient of the battery.
\end{itemize}

Equation~\eqref{eq:soc_evolution} captures the SOC update at each time step, accounting for charging efficiency losses and discharging efficiency losses.

The model enforces power limits by bounding $c_t$ and $d_t$ within maximum charge and discharge rates, and constrains the SOC within minimum and maximum bounds representing the safe operating range (e.g., a minimum SOC of 10\% of capacity and a maximum of 100\%).

The following code sample shows the implementation of the already described logical requirement for mutual exclusivity of charging and discharging which is enforced using binary variables to avoid simultaneous operations:

\begin{PythonCode}
# Binary variables for operational states
model.charge_binary = Var(model.T, domain=Binary)
model.discharge_binary = Var(model.T, domain=Binary)

# Mutual exclusivity constraint: charge and discharge cannot both be active
model.mutual_exclusivity = Constraint(
    model.T,
    rule=lambda m, t: m.charge_binary[t] + m.discharge_binary[t] <= 1
)

# Linking binary variables to continuous power variables via big-M constraints
model.charge_binary_link = Constraint(
    model.T,
    rule=lambda m, t: m.charge[t] <= m.max_charge_rate * m.charge_binary[t]
)

model.discharge_binary_link = Constraint(
    model.T,
    rule=lambda m, t: m.discharge[t] <= m.max_discharge_rate * m.discharge_binary[t]
)
\end{PythonCode}



### Economic Penalty Mechanisms

To reflect real-world economic factors affecting battery lifespan and operational costs, the model incorporates penalty terms linearized via auxiliary variables.

\paragraph{Cycle Penalties}
Cycle penalties discourage excessive battery cycling by estimating fractional cycle usage proportional to energy throughput. This is mathematically expressed as:

\begin{equation}
\label{eq:cycle_penalty}
\alpha_t \geq \frac{c_t \cdot \Delta t + d_t \cdot \Delta t}{2 \cdot B_{\mathrm{cap}}}
\end{equation}

\noindent where
\begin{itemize}
- $\alpha_t$ is an auxiliary variable representing fractional cycle usage at time $t$,
- $c_t$ and $d_t$ are charging and discharging powers (MW),
- $\Delta t$ is the time step duration (hours),
- $B_{\mathrm{cap}}$ is the battery capacity (MWh).
\end{itemize}

The following Pyomo code implements this constraint:

\begin{PythonCode}
def cycle_penalty_rule(m, t):
    energy_throughput = (m.charge[t] + m.discharge[t]) * TIME_STEP_HOURS
    cycle_fraction = energy_throughput / (2 * m.battery_capacity)
    return m.aux_cycle[t] >= cycle_fraction

model.cycle_penalty_constraint = Constraint(model.T, rule=cycle_penalty_rule)
\end{PythonCode}

\paragraph{Depth-of-Discharge (DoD) Penalties}

Depth-of-discharge penalties impose costs when discharging at low SOC levels. The conditional penalty is modeled as:

\begin{equation}
\label{eq:aux_dod_definition}
aux_{\mathrm{dod},t} =
\begin{cases}
K_{\mathrm{DoD}} \cdot d_t \cdot \Delta t & \text{if } u^{\mathrm{low}}_t = 1 \\
0 & \text{if } u^{\mathrm{low}}_t = 0
\end{cases}
\end{equation}

\noindent where
\begin{itemize}
- $aux_{\mathrm{dod},t}$ is the auxiliary variable representing the DoD penalty at time $t$,
- $K_{\mathrm{DoD}}$ (EUR/MWh) is the penalty cost coefficient for discharging below the SOC threshold,
- $d_t$ (MW) is the battery discharging power at time $t$,
- $\Delta t$ (hours) is the time step length,
- $u^{\mathrm{low}}_t \in {0,1}$ is a binary variable equal to 1 when SOC is below the threshold at time $t$, 0 otherwise.
\end{itemize}

This conditional penalty is enforced in Pyomo through a three-constraint Big-M \cite{soleimani2008modified} linearization:

\begin{PythonCode}
def dod_penalty_calculation_rule(m, t):
discharge_energy = m.discharge[t] * TIME_STEP_HOURS
M = m.k_dod * m.max_discharge_rate * TIME_STEP_HOURS
return m.aux_dod[t] <= M * m.low_soc_binary[t]

def dod_penalty_upper_bound_rule(m, t):
discharge_energy = m.discharge[t] * TIME_STEP_HOURS
return m.aux_dod[t] <= m.k_dod * discharge_energy

def dod_penalty_lower_bound_rule(m, t):
discharge_energy = m.discharge[t] * TIME_STEP_HOURS
M = m.k_dod * m.max_discharge_rate * TIME_STEP_HOURS
return m.aux_dod[t] >= m.k_dod * discharge_energy - M * (1 - m.low_soc_binary[t])
\end{PythonCode}

This set of constraints ensures that the penalty $aux_{\mathrm{dod},t}$ is applied only when the battery discharges below the comfortable SOC threshold, maintaining a mathematically tractable linear formulation.

### Solver Integration and Performance

During development, multiple solvers were evaluated. The default solver for the MILP model is HiGHS \cite{huangfu2018}, which is accessed through Pyomo's SolverFactory interface. The solver is configured with a mipgap tolerance of 1\% and a time limit of 300 seconds to balance solution quality and computational efficiency suitable for near real-time operation.

The prototype supports flexible battery configurations via parameterized inputs, enabling exploration of varying battery capacities, efficiencies, and economic parameters. Optimal solutions are retrieved using Pyomo’s \texttt{value()} function, with solution feasibility and optimality validated based on solver termination conditions.

Integration with the API (described in section \ref{subsec:api_integration}) automates data retrieval and result storage, facilitating seamless interaction within the larger system architecture. Post-optimization analysis calculates cumulative revenue, energy throughput, and other key operational metrics to evaluate and monitor trading strategies.


## System Integration and Post-Processing

The optimization module seamlessly integrates with the Integration API (see section \ref{subsec:api_integration}) using the \texttt{requests} library to automate data input and output storage. Results are extracted using Pyomo’s \texttt{value()} function, while solution feasibility and optimality are verified by checking solver termination conditions.

Post-optimization, the system calculates cumulative revenue, energy throughput, and other operational metrics to evaluate the effectiveness of trading strategies and battery usage.

 -->
